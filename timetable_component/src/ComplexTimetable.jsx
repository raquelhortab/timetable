class ComplexTimetable extends Timetable{

    /*

    A ComplexTimetable cannot be modified by clicking on time slots as it only represents the mix of a bunch of independent timetables.
    The best approach is to initialize it with a hash of timeRanges and update it via the "updateMatrix" method.

       STATE:
       timeRanges: hash where each key corresponds to a sub-timetable's id and the value corresponds to an array of timeRanges,
                   which are hashes, eg: [{day:"monday", from:7, to:15, tag:"1"},...]
                   tag is optional
       timeMatrix: autogenerated, hash of arrays with keys from "monday" to "sunday"
                   and arrays with (end-start)*2 number of items, corresponding to each half-hour slot
                   the value of each item in the arrays is a number representing the quantity of different ranges in that slot
       mode: "select", "deselect"
             determines whether a click on a slot will activate or deactivate such slot
             if props.modifiable is set to false, state.mode is ignored
    */
    constructor(props){
        super(props);
        this.state = {
            timeRanges: this.props.initialTimeRanges || {},
            timeMatrix: this.generateMatrix(this.props.initialTimeRanges || {})
        };
        if(this.props.subscribeTo !== undefined){
            this.props.subscribeTo.subscribe(this.updateMatrix);
        }
    }

    exportData(){
    }

    emptyMatrix(){
        var rowCount = this.hourRowCount();
        return({
            monday: Array(rowCount).fill(null).map(()=> ([])),
            tuesday: Array(rowCount).fill(null).map(()=> ([])),
            wednesday: Array(rowCount).fill(null).map(()=> ([])),
            thursday: Array(rowCount).fill(null).map(()=> ([])),
            friday: Array(rowCount).fill(null).map(()=> ([])),
            saturday:Array(rowCount).fill(null).map(()=> ([])),
            sunday: Array(rowCount).fill(null).map(()=> ([])),
        });
    }

    //TODO: acabar aixo, en comptes de += fer push de key
    generateMatrix(timeRanges){
        var matrix = this.emptyMatrix();
        var ids = Object.keys(timeRanges);
        ids.forEach(function (key,_) {
            var array = timeRanges[key];
            array.forEach(function (element, _) {
                var from = Math.max(element.from,this.startTime());
                var to = Math.min(element.to,this.endTime());
                for(var iterator = from; iterator < to ; iterator+=0.5){
                    var row = this.calculateRow(iterator);
                    matrix[element.day][row].push(key);
                }
            }, this);
        }, this);
        return(matrix);
    }

    calculateTimeRanges(matrix){

        //TODO
        return([]);

    }

    updateMatrix(data) {
        var day = data["day"];
        var hour = data["hour"];
        var value = data["value"];
        var key = data["key"];

        var matrix = Object.assign({}, this.state.timeMatrix);
        var row = this.calculateRow(hour);
        if(value === true) matrix[day][row].push(key);
        else matrix[day][row] = matrix[day][row].filter((x)=> x!==key);
        if(this.autoUpdate()){
            this.setState({timeMatrix: matrix,timeRanges:this.calculateTimeRanges(matrix)});
        }
        else{
            this.setState({timeMatrix: matrix});
        }
    }


    onSlotClickHandler(slot){
        // Complex Timetables are for now unmodifiable
    }

    timeSlotKind(){
        return(ComplexTimeSlot);
    }

}